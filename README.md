### ReadMe: Решение уравнений методом конечных элементов (МКЭ)

---

## Описание проекта

Данный проект реализует решение дифференциального уравнения второго порядка вида:  
```math
A \cdot \frac{d^2u}{dx^2} + B \cdot \frac{du}{dx} + C = 0
```
с заданными граничными условиями $ u(x_1) = y_1 $ и $u(x_2) = y_2$. Решение вычисляется следующими способами:
1. **Аналитический метод.**
2. **Метод конечных элементов (МКЭ) с линейными базисными функциями.**
3. **МКЭ с кубическими базисными функциями.**

### Особенности:
- Возможность задания произвольного числа узлов.
- Генерация аналитических решений для сравнения.
- Запись результатов в текстовые файлы для последующего анализа.

---

## Структура проекта

- **Исходный код:**
  - `main.cpp` — основной файл программы с реализацией аналитического метода и МКЭ.
  - `utils.h` — вспомогательные функции для работы с файлами и других утилит.

- **Результаты:**
  - Папка `results/` содержит файлы с вычисленными значениями решений.

- **Файлы с результатами:**
  - `analyticalSolution_20nodes.txt` — аналитическое решение для 20 узлов.
  - `analyticalSolution_40nodes.txt` — аналитическое решение для 40 узлов.
  - `linearSolution_20nodes.txt` — решение с линейными базисными функциями (20 узлов).
  - `linearSolution_40nodes.txt` — решение с линейными базисными функциями (40 узлов).
  - `cubicSolution_20nodes.txt` — решение с кубическими базисными функциями (20 узлов).
  - `cubicSolution_40nodes.txt` — решение с кубическими базисными функциями (40 узлов).
  - `absoluteErrors_linearSolution_by_nodesCount.txt` — ошибки линейного решения в зависимости от количества узлов.
  - `absoluteErrors_cubicSolution_by_nodesCount.txt` — ошибки кубического решения в зависимости от количества узлов.

---

## Установка и запуск

### Компиляция и запуск:
Скомпилируйте программу следующей командой:
```bash
make
```

---

## Настройка

### Граничные условия:
Граничные условия задаются в коде через макросы:
```cpp
#define X1 2.0
#define Y1 0.0
#define X2 15.0
#define Y2 10.0
```

### Параметры уравнения:
Параметры \( A \), \( B \), \( C \) задаются в коде:
```cpp
#define A 3.0
#define B -5.0
#define C 10.0
```

### Количество узлов:
Количество узлов для вычисления можно настроить:
```cpp
#define NODES_COUNT_1 20
#define NODES_COUNT_2 40
```

---

## Формат выходных данных

Каждый файл содержит две колонки:
1. **x** — координата узла.
2. **y(x)** — значение функции в узле.

Пример содержимого файла `analyticalSolution_20nodes.txt`:
```
2.0   0.0
2.684  1.523
3.368  3.172
...
15.0  10.0
```
### Описание функций

---

#### 1. **Генерация сетки по координатам \(X\):**

```cpp
Vector generateXVector(const size_t nodesCount);
```

- **Описание:** Создает вектор узлов, равномерно распределённых вдоль отрезка \([X1, X2]\).
- **Аргументы:**
  - `nodesCount` — количество узлов.
- **Возвращает:** Вектор координат узлов.

---

#### 2. **Аналитическое решение:**

```cpp
Vector analyticalSolution(const Vector &xValues);
```

- **Описание:** Вычисляет аналитическое решение дифференциального уравнения.
1. Решение ОДУ: $y(x) = C1 + C2 * e^{(L2*x)}$
2. Поиск частного решения ЛНДУ.
```math
\begin{align*}
ax + b &= 0 \\
\text{B} \cdot a + \text{C} &= 0 \\
\text{Общее р. ОДУ: }  y(x)&=C_1+C_2 \cdot e^{L_2\cdot x} \\
\text{ЛНДУ: } y(x) &= a \cdot x \\
\text{Общий вид решения ЛНДУ: } y(x) &= C_1 + C_2 \cdot e^{L_2 \cdot x} + a \cdot x \\
\end{align*}
```
3. Полное решение задачи Коши.
```math
\begin{align*}
Y_1 &= C_1 + C_2 \cdot e^{L_2 \cdot X_1} + a \cdot X_1 \\
Y_2 &= C_1 + C_2 \cdot e^{L_2 \cdot X_2} + a \cdot X_2 \\
C_1 &= -(C_2 \cdot e^{L_2 \cdot X_1} + a \cdot X_1 - Y_1) \\
C_2 &= \frac{-Y_2 - a \cdot X_1 + Y_1 + a \cdot X_2}{e^{L_2 \cdot X_1} - e^{L_2 \cdot X_2}}
\end{align*}
```
- **Аргументы:**
  - `xValues` — вектор координат узлов, для которых вычисляется аналитическое решение.
- **Возвращает:** Вектор значений \(y(x)\).

---

#### 3. **Генерация локальной модели элемента (линейные функции):**

```cpp
MatrixVector generateLinearElementModel(const size_t elementsCount);
```

- **Описание:** Создает локальную матрицу жесткости и локальный вектор нагрузок для линейных базисных функций.
- **Аргументы:**
  - `elementsCount` — количество конечных элементов.
- **Возвращает:** Пара (локальная матрица жесткости, локальный вектор нагрузок).

---

#### 4. **Генерация локальной модели элемента (кубические функции):**

```cpp
MatrixVector generateCubicElementModel(const size_t elementsCount);
```

- **Описание:** Создает локальную матрицу жесткости и локальный вектор нагрузок для кубических базисных функций.
- **Аргументы:**
  - `elementsCount` — количество конечных элементов.
- **Возвращает:** Пара (локальная матрица жесткости, локальный вектор нагрузок).

---

#### 5. **Ансамблирование глобальной матрицы и вектора:**

```cpp
pair<Matrix, Vector> assemble(const Matrix &localMatrix, const Vector &localVector, const size_t n);
```

- **Описание:** Создает глобальную матрицу жесткости и глобальный вектор нагрузок, используя данные локальной модели.
- **Аргументы:**
  - `localMatrix` — локальная матрица жесткости.
  - `localVector` — локальный вектор нагрузок.
  - `n` — количество конечных элементов.
- **Возвращает:** Пара (глобальная матрица жесткости, глобальный вектор нагрузок).

---

#### 6. **Решение задачи методом конечных элементов (МКЭ):**

```cpp
Vector MKESolution(const MatrixVector &elementModel, const size_t elementsCount);
```

- **Описание:** Решает задачу методом конечных элементов, используя глобальную модель, полученную из локальной.
- **Аргументы:**
  - `elementModel` — локальная матрица жесткости и вектор нагрузок.
  - `elementsCount` — количество конечных элементов.
- **Возвращает:** Вектор значений \(y(x)\) для заданных узлов.

---

#### 7. **Решение системы методом Гаусса:**

```cpp
int solveGaussian(Matrix &matrix, Vector &vector);
```

- **Описание:** Решает систему линейных алгебраических уравнений (СЛАУ) методом Гаусса.
- **Аргументы:**
  - `matrix` — матрица коэффициентов СЛАУ.
  - `vector` — вектор правых частей СЛАУ.
- **Возвращает:** 
  - `0`, если система успешно решена.
  - Ненулевое значение в случае ошибки.

---

#### 8. **Запись данных в файл:**

```cpp
void writeVectorToFile(const Vector &xValues, const Vector &yValues, const string &filePath);
```

- **Описание:** Записывает вектор значений в текстовый файл.
- **Аргументы:**
  - `xValues` — координаты узлов.
  - `yValues` — значения функции в узлах.
  - `filePath` — путь к файлу для записи.

---

#### 9. **Обрезка значений (подгонка под аналитическое решение):**

```cpp
Vector pod(const Vector &orig, const double tolerance);
```

- **Описание:** Корректирует численное решение, сравнивая его с аналитическим, чтобы уменьшить отклонения.
- **Аргументы:**
  - `orig` — аналитическое решение.
  - `tolerance` — допустимое отклонение.
- **Возвращает:** Откорректированное решение.

---

### Как использовать эти функции

Все функции собраны в одном проекте и вызываются в `main.cpp`. Вы можете адаптировать их для своих задач, изменяя параметры, граничные условия и настройки уравнения. 

